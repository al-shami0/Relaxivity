# -*- coding: utf-8 -*-
"""R2_finals_ok.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13DTO2chasBjWZHrDVz4cxADZCa4tAYlz
"""

!pip install pymatgen

from collections import abc
import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import mu_0, pi, k
from scipy.special import erf

# Constants
gamma_H = 42.577e6    # rad/(T·s), gyromagnetic ratio of proton.
D = 2.3e-9            # m^2/s, water self-diffusion coefficient.
N = 3.4e13            # 1/m^3, number of particles per unit volume.
R = 5.71e-9           # m, particle radius.
d = 0.7e-9            # m, dead layer thickness.
R_m = R - d           # m, magnetic core radius.
M_S = 0.52668 / mu_0  # A/m, saturation magnetization converted from T to A/m.
k_B = k               # J/K, Boltzmann constant.
T = 300               # K, temperature.
eta = 8.90e-4         # Pa·s, viscosity of water.
tau_0 = 4.2e-5        # s, attempt time.
Kn = 1.5e5            # J/m^3, anisotropy constant (assumed value).

# Magnetic moments
V_m = (4/3) * pi * R_m**3  # m^3, volume of the magnetic domain.
mu = M_S * V_m             # A·m^2, magnetic moment.

def compute_magnetic_moment_averages(mu, B_0, k_B, T):
    """
    Compute the average and variance of the longitudinal and transversal components of the magnetic moment.

    Parameters:
        mu (float): Magnetic moment (A·m^2)
        B_0 (float): External magnetic field (T)
        k_B (float): Boltzmann constant (J/K)
        T (float): Temperature (K)

    Returns:
        tuple: (mu_parallel_mean, mu_parallel_mean_squared, mu_parallel_variance, mu_perp_squared_mean)
    """
    # Langevin function: L(x) = coth(x) - 1/x
    def L(x):
        # Handle x=0 to avoid division by zero.
        with np.errstate(divide='ignore', invalid='ignore'):
            return np.where(x != 0, 1 / np.tanh(x) - 1/x, 0.0)

    x = mu * B_0 / (k_B * T)
    L_x = L(x)
    mu_parallel_mean = mu * L_x
    mu_parallel_mean_squared = mu_parallel_mean**2
    mu_parallel_squared_mean = mu**2 * ((3 * L_x) / x - L_x**2)
    mu_parallel_variance = mu_parallel_squared_mean - mu_parallel_mean_squared
    mu_perp_squared_mean = (1/2) * (mu**2 - mu_parallel_squared_mean)
    return mu_parallel_mean, mu_parallel_mean_squared, mu_parallel_variance, mu_perp_squared_mean

# External magnetic field (Tesla)
B_0 = 1.5  # T, typical MRI field strength.

# Compute magnetic moment averages
mu_parallel_mean, mu_parallel_mean_squared, mu_parallel_variance, mu_perp_squared_mean = compute_magnetic_moment_averages(mu, B_0, k_B, T)

# Relaxation times
tau_N = tau_0 * np.exp(Kn * V_m / (k_B * T))  # s, Néel relaxation time.
tau_B = (4 * pi * eta * R**3) / (k_B * T)    # s, Brownian relaxation time.

# Effective relaxation times (assuming independent processes)
# Using Matthiessen's rule for combined relaxation times
tau_perp = 1 / (1 / tau_N + 1 / tau_B)      # s, transversal relaxation time.
tau_parallel = tau_B                       # s, longitudinal relaxation time.

# Sojourn time
tau_D = R**2 / D  # s.

# Function g(x)
def g_function(x):
    """
    Compute the real part of the function g(x) as defined in the theoretical model.

    Parameters:
        x (complex or float): Input value (can be complex)

    Returns:
        float: Real part of g(x)
    """
    sqrt_x = np.sqrt(x)
    numerator = 1 + sqrt_x / 4
    denominator = 1 + sqrt_x + (4 * x) / 9 + (sqrt_x * x) / 9
    return np.real(numerator / denominator)

# Frequency range: 0.1 MHz to 1000 MHz
omega_I = np.linspace(0.1e6 * 2 * pi, 1000e6 * 2 * pi, 1000)  # rad/s.

# Precompute constants
prefactor = ((mu_0 * gamma_H)**2) / (135 * pi) * (N / (D * R))

# Compute constant term C
x_c_perp = tau_D / tau_perp
x_c_parallel = tau_D / tau_parallel

g_c_perp = g_function(x_c_perp)
g_c_parallel = g_function(x_c_parallel)

C_transversal = 3 * mu_perp_squared_mean * g_c_perp
C_fluctuation = 4 * mu_parallel_variance * g_c_parallel
C_curie = 4 * mu_parallel_mean_squared

C = prefactor * (C_transversal + C_fluctuation + C_curie)

# Prepare arrays for results
R2 = np.zeros_like(omega_I)
transversal_contribution = np.zeros_like(omega_I)
curie_term = np.zeros_like(omega_I)
fluctuation_term = np.zeros_like(omega_I)

# Compute frequency-dependent term V(omega_I).
for idx, omega in enumerate(omega_I):
    # Compute complex arguments
    x_v_perp = tau_D * (1j * omega + 1 / tau_perp)
    x_v_parallel = tau_D * (1j * omega + 1 / tau_parallel)
    x_v_zero = tau_D * (1j * omega)

    # Compute g functions
    g_v_perp = g_function(x_v_perp)
    g_v_parallel = g_function(x_v_parallel)
    g_v_zero = g_function(x_v_zero)

    # Compute V components
    V_transversal = (7/2) * mu_perp_squared_mean * g_v_perp
    V_fluctuation = 3 * mu_parallel_variance * g_v_parallel
    V_curie = 3 * mu_parallel_mean_squared * g_v_zero

    # Total V
    V = V_transversal + V_fluctuation + V_curie

    # Update R2 and its components
    R2[idx] = C + prefactor * np.real(V)
    transversal_contribution[idx] = prefactor * np.real(V_transversal)
    curie_term[idx] = prefactor * np.real(V_curie)
    fluctuation_term[idx] = prefactor * np.real(V_fluctuation)

# Convert R2 to relaxivity r2 (assuming [Fe + Co] = N * V_particle in mol/L).
V_particle = (4/3) * pi * R**3  # m^3, volume of a single particle.
particle_concentration = N * V_particle  # particles/m^3.
# Convert particles/m^3 to mol/L: (particles/m^3) * (1 mol / 6.022e23 particles) * (1 m^3 / 1000 L).
particle_concentration_mol_L = particle_concentration / 6.022e23 / 1e3  # mol/L.

# Avoid division by zero
particle_concentration_mol_L = np.where(particle_concentration_mol_L == 0, 1e-12, particle_concentration_mol_L)

# Compute relaxivities
r2 = R2 / particle_concentration_mol_L  # s^-1·(mol/L)^-1.
transversal_contribution_r = transversal_contribution / particle_concentration_mol_L
curie_term_r =  (fluctuation_term / particle_concentration_mol_L)
fluctuation_term_r = curie_term / particle_concentration_mol_L
#RTC=transversal_contribution_r *10e-31
#RC=(curie_term_r ) *10e-31 + 60
#RFC=fluctuation_term_r *10e-31
#r2 = (RTC + RC + RFC)  # s^-1·(mol/L)^-1.


# Plotting
plt.figure(figsize=(12, 8))
plt.plot(omega_I / (2 * pi * 1e6), r2, label=r'$r_2(\omega_I)$', linewidth=2)
plt.plot(omega_I / (2 * pi * 1e6), transversal_contribution_r , label='Transversal Contribution', linestyle='--')
plt.plot(omega_I / (2 * pi * 1e6), curie_term_r, label='Curie Term', linestyle='-.')
plt.plot(omega_I / (2 * pi * 1e6), fluctuation_term_r, label='Fluctuation Term', linestyle=':')
#plt.plot(omega_I / (2 * pi * 1e6), RTC , label='Transversal Contribution', linestyle='--').
#plt.plot(omega_I / (2 * pi * 1e6), RC, label='Curie Term', linestyle='-.').
#plt.plot(omega_I / (2 * pi * 1e6), RFC, label='Fluctuation Term', linestyle=':').
plt.xlabel(r'Frequency $\omega_I$ (MHz)', fontsize=14)
plt.ylabel(r'$r_2$ (s$^{-1}$·(mol/L)$^{-1}$)', fontsize=14)
plt.title('Relaxivity $r_2(\omega_I)$ and its Contributions vs Frequency', fontsize=16)
plt.xscale("log")
plt.legend(fontsize=12)
plt.grid(True)
plt.tight_layout()
plt.show()